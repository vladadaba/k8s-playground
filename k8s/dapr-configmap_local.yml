apiVersion: v1
kind: ConfigMap
metadata:
  name: dapr-local-configmap
  labels:
    name: dapr-local-configmap
    app: myapp
    type: backend
# generated using `kubectl create configmap --dry-run=client somename --from-file=./volumes/infra/dapr/components/local --output yaml`
# TODO: use Helm to generate this
data:
  local-secrets.yml: |-
    apiVersion: dapr.io/v1alpha1
    kind: Component
    metadata:
      name: localsecrets
      namespace: default
    spec:
      type: secretstores.local.file
      version: v1
      metadata:
      - name: secretsFile
        value: "/dapr/local/secrets.json"
      - name: nestedSeparator
        value: ":"
  rabbitmq-pubsub-subscriptions.yml: |
    apiVersion: dapr.io/v2alpha1
    kind: Subscription # https://docs.dapr.io/reference/resource-specs/subscription-schema/
    metadata:
      name: rabbitmq-my_topic-subscription
    spec:
      pubsubname: rabbitmqbus
      topic: my_topic
      routes:
        rules:
          - path: /rabbitmq_consumer
    scopes:
      - app2
      - app3
  rabbitmq-pubsub.yml: |
    apiVersion: dapr.io/v1alpha1
    kind: Component
    metadata:
      name: rabbitmqbus
      namespace: default
    spec:
      type: pubsub.rabbitmq
      metadata:
        - name: host
          value: "amqp://demo:demo@rabbitmq:5672/"
        - name: consumerID
          value: "dapr_rabbit"
        - name: durable
          value: "false"
        - name: deletedWhenUnused
          value: "false"
  redis-pubsub-subscriptions.yml: |
    apiVersion: dapr.io/v2alpha1
    kind: Subscription # https://docs.dapr.io/reference/resource-specs/subscription-schema/
    metadata:
      name: redis-my_topic-subscription
    spec:
      pubsubname: redisbus
      topic: my_topic
      routes:
        rules:
          - path: /redis_consumer
    scopes:
      - app2
      - app3
  redis-pubsub.yml: |
    apiVersion: dapr.io/v1alpha1
    kind: Component
    metadata:
      name: redisbus
      namespace: default
    spec:
      type: pubsub.redis
      version: v1
      metadata:
        - name: redisHost
          value: redis:6379
        - name: redisPassword
          secretKeyRef:
            name: redisPassword
            key: redisPassword
    auth:
      secretStore: localsecrets
  redis-state.yml: |
    apiVersion: dapr.io/v1alpha1
    kind: Component
    metadata:
      name: statestore
      namespace: default
    spec:
      type: state.redis
      metadata:
        - name: redisHost
          value: redis:6379
        - name: redisPassword
          secretKeyRef:
            name: redisPassword
            key: redisPassword
        - name: actorStateStore # Required for workflow engine
          value: "true"
    auth:
      secretStore: localsecrets
  resiliency.yml: |
    apiVersion: dapr.io/v1alpha1
    kind: Resiliency
    metadata:
      name: app1-to-app2-resiliency
    scopes:
      - app1

    spec:
      policies:
        retries:
          retryForever:
            policy: constant
            duration: 1s
            maxRetries: -1

        circuitBreakers:
          simpleCB:
            maxRequests: 1
            timeout: 5s
            trip: consecutiveFailures >= 3

      targets:
        apps:
          app2:
            retry: retryForever
            # circuitBreaker: simpleCB
  secrets.json: |
    {
      "redisPassword": "somepassword"
    }
  workflow-actor.yml: |
    apiVersion: dapr.io/v1alpha1
    kind: Component
    metadata:
      name: actorbackend
    spec:
      type: workflowbackend.actor
      version: v1
      metadata:
        - name: actorIdleTimeout
          value: "5m"
        - name: actorScanInterval
          value: "30s"
        - name: drainOngoingCallTimeout
          value: "1m"
        - name: drainRebalancedActors
          value: true
